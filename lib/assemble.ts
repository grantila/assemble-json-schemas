'use strict'

import { readFile, writeFile, appendFile } from 'fs'
import { parse, ParsedPath } from 'path'
import * as promisify from 'util.promisify'
import { compile, DEFAULT_OPTIONS } from 'json-schema-to-typescript'

import { findFiles, FindFilesOptions } from './find-files'
import { compile as tsCompile } from './compile'

const readFileAsync = promisify( readFile );
const writeFileAsync = promisify( writeFile );
const appendFileAsync = promisify( appendFile );


function camelCaseify( text: string ): string
{
	return text.replace( /(-.)/g, two => two.charAt( 1 ).toUpperCase( ) );
}

export interface Options
{
	interfaceNamer?: ( filename: string ) => string;
	findOptions?: FindFilesOptions;
}

const defaultOptions: Options = {
	interfaceNamer: defaultInterfaceNamer,
	findOptions: { followSymlinks: false },
}


function defaultInterfaceNamer( filename: string )
{
	return filename.charAt( 0 ).toUpperCase( ) + filename.substr( 1 );
}

interface File
{
	path: ParsedPath;
	content: string;
}

function compileSchemasToTypescript( files: File[], options: Options )
: Promise< string >
{
	const jsttOpts = {
		...DEFAULT_OPTIONS,
		indentWith: "\t",
		bannerComment: "",
	};

	return Promise.all(
		files.map( ( file, index ) =>
			compile(
				JSON.parse( file.content ),
				options.interfaceNamer( camelCaseify( file.path.name ) ),
				jsttOpts
			)
		)
	)
	.then( definitions => definitions.join( "\n" ) );
}

function assembledSchemasAsTypescript( files: File[], tsFile: string )
: Promise< void >
{
	return writeFileAsync(
		tsFile,
		files
			.map( file =>
			{
				const name = camelCaseify( file.path.name );
				const schema = file.content;

				return `export const ${ name } = ${ schema }`
			} )
			.join( "\n" )
	);
}

async function prependHeader( file: string ): Promise< void >
{
	const header = `
/**
 * This file was automatically generated by assemble-json-schemas.
 * DO NOT MODIFY IT BY HAND.
 */

`;

	const content = await readFileAsync( file );
	await writeFileAsync( file, header + content );
}

export function assemble(
	schemaDir: string,
	outFile: string,
	options?: Options
): Promise< void >
{
	const opts = options ? { ...defaultOptions, ...options } : defaultOptions;

	const jsFile = `${outFile}.js`;
	const tsFile = `${outFile}.ts`;
	const dtsFile = `${outFile}.d.ts`;

	return findFiles( schemaDir, opts.findOptions )
	// Same sort-order between runs, produces nicer diffs
	.then( files => files.sort( ) )
	.then( files =>
		Promise.all(
			files.map( filename =>
				readFileAsync( filename )
				.then( content =>
					( { path: parse( filename ), content } )
				)
			)
		)
	)
	.then( files =>
		Promise.all( [
			compileSchemasToTypescript( files, opts ),
			assembledSchemasAsTypescript( files, tsFile )
		] )
	)
	.then( ( [ interfaces, _ ] ) =>
		tsCompile( tsFile )
		.then( ( ) => appendFileAsync( dtsFile, "\n" + interfaces ) )
		.then( ( ) => Promise.all( [
			prependHeader( jsFile ),
			prependHeader( tsFile ),
			prependHeader( dtsFile ),
		] ) )
		.then( ( ) => { } )
	);
}
